"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteGenerator = void 0;
const fluent_ffmpeg_1 = __importDefault(require("fluent-ffmpeg"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const moment_1 = __importDefault(require("moment"));
const path_1 = __importDefault(require("path"));
class SpriteGenerator {
    constructor(options) {
        var _a, _b, _c;
        this.rowCount = 5;
        this.colCount = 5;
        this.height = 90;
        this.width = 160;
        this.multiple = false;
        this.thumbnailPrefix = 'thumbs';
        this.webVTTRequired = false;
        if (((_a = options === null || options === void 0 ? void 0 : options.webVTT) === null || _a === void 0 ? void 0 : _a.required) === true && ((_b = options === null || options === void 0 ? void 0 : options.webVTT) === null || _b === void 0 ? void 0 : _b.path) === undefined) {
            throw new Error('webVTT path not found');
        }
        if ((_c = options === null || options === void 0 ? void 0 : options.webVTT) === null || _c === void 0 ? void 0 : _c.required) {
            this.webVTTRequired = true;
            this.webVTTPath = options.webVTT.path;
        }
        this.outputDir = options.outputDir;
        this.inputPath = options.inputPath;
        this.rowCount = options.rowCount || this.rowCount;
        this.colCount = options.colCount || this.colCount;
        this.multiple = options.multiple || this.multiple;
        this.height = options.height || this.height;
        this.width = options.width || this.width;
        this.interval = options.interval || undefined;
        this.thumbnailPrefix = options.thumbnailPrefix || this.thumbnailPrefix;
    }
    getFPS() {
        const defaultFps = 24;
        return new Promise((resolve, reject) => {
            fluent_ffmpeg_1.default(this.inputPath).ffprobe((err, data) => {
                if (err) {
                    reject(err);
                }
                const videoStream = data.streams[0];
                const fpsString = (videoStream === null || videoStream === void 0 ? void 0 : videoStream.r_frame_rate) || (videoStream === null || videoStream === void 0 ? void 0 : videoStream.avg_frame_rate);
                if (!fpsString) {
                    resolve(defaultFps);
                    return;
                }
                const [numerator, denominator] = fpsString.split('/');
                if (Number(numerator) && Number(denominator)) {
                    const fps = Math.round(Number(numerator) / Number(denominator));
                    resolve(fps);
                }
                resolve(defaultFps);
            });
        });
    }
    getDuration() {
        return new Promise((resolve, reject) => {
            fluent_ffmpeg_1.default(this.inputPath).ffprobe((err, data) => {
                if (err) {
                    reject(err);
                }
                const { duration } = data.format;
                if (Number(duration)) {
                    resolve(Number(duration));
                }
                resolve(0);
            });
        });
    }
    generate() {
        return __awaiter(this, void 0, void 0, function* () {
            const inputExists = yield fs_extra_1.default.pathExists(this.inputPath);
            if (!inputExists) {
                throw new Error('input file not found');
            }
            yield fs_extra_1.default.ensureDir(this.outputDir);
            const interval = yield this.getOptimalInterval();
            if (!this.multiple) {
                const duration = yield this.getDuration();
                if (duration === 0) {
                    throw new Error('could not fetch duration from video');
                }
                const totalImages = Math.floor(duration / interval);
                this.rowCount = Math.floor(totalImages / this.colCount);
            }
            const fps = yield this.getFPS();
            const outputDirPath = path_1.default.join(this.outputDir, `${this.thumbnailPrefix}-%02d.jpg`);
            const complexFilter = `select='not(mod(n,${fps * interval}))',scale=${this.width}:${this.height},tile=${this.colCount}x${this.rowCount}`;
            return new Promise((resolve, reject) => {
                fluent_ffmpeg_1.default(this.inputPath)
                    .complexFilter(complexFilter)
                    .outputOption(['-vsync', 'vfr', '-an'])
                    .output(outputDirPath)
                    .on('start', () => {
                })
                    .on('end', () => {
                    if (this.webVTTRequired) {
                        this.generateWebVTT().then(() => {
                            resolve();
                        });
                    }
                    else {
                        resolve();
                    }
                })
                    .on('error', err => {
                    reject(err);
                })
                    .run();
            });
        });
    }
    generateWebVTT() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.webVTTPath || !this.webVTTRequired) {
                return;
            }
            if (this.webVTTPath.split('.').pop() !== 'vtt') {
                throw new Error('webVTT path must be a vtt file');
            }
            const duration = yield this.getDuration();
            const interval = yield this.getOptimalInterval();
            const col = this.colCount;
            let row = this.rowCount;
            let thumbOutput = 'WEBVTT\n\n';
            const startTime = moment_1.default('00:00:00', 'HH:mm:ss.SSS');
            const endTime = moment_1.default('00:00:00', 'HH:mm:ss.SSS').add(interval, 'seconds');
            const totalImages = Math.floor(duration / interval);
            if (!this.multiple) {
                row = Math.floor(totalImages / this.colCount);
                for (let i = 0; i < row; i++) {
                    for (let j = 0; j < col; j++) {
                        const currentImageCount = i * col + j;
                        if (currentImageCount > totalImages) {
                            break;
                        }
                        thumbOutput += `${startTime.format('HH:mm:ss.SSS')} --> ${endTime.format('HH:mm:ss.SSS')}\n`;
                        thumbOutput += `${this.thumbnailPrefix}-01.jpg#xywh=${j * this.width},${i * this.height},${this.width},${this.height}\n\n`;
                        startTime.add(interval, 'seconds');
                        endTime.add(interval, 'seconds');
                    }
                }
            }
            else {
                const totalSpirits = Math.ceil(duration / interval / (row * col));
                for (let k = 0; k < totalSpirits; k++) {
                    for (let i = 0; i < row; i++) {
                        for (let j = 0; j < col; j++) {
                            const currentImageCount = k * row * col + i * col + j;
                            if (currentImageCount > totalImages) {
                                break;
                            }
                            thumbOutput += `${startTime.format('HH:mm:ss.SSS')} --> ${endTime.format('HH:mm:ss.SSS')}\n`;
                            thumbOutput += `${this.thumbnailPrefix}-${k + 1 < 10 ? '0' : ''}${k + 1}.jpg#xywh=${j * this.width},${i * this.height},${this.width},${this.height}\n\n`;
                            startTime.add(interval, 'seconds');
                            endTime.add(interval, 'seconds');
                        }
                    }
                }
            }
            fs_extra_1.default.writeFileSync(this.webVTTPath, thumbOutput);
        });
    }
    getOptimalInterval() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.interval)
                return this.interval;
            const duration = yield this.getDuration();
            if (duration < 120)
                return 1;
            if (duration < 300)
                return 2;
            if (duration < 600)
                return 3;
            if (duration < 1800)
                return 4;
            if (duration < 3600)
                return 5;
            if (duration < 7200)
                return 10;
            if (duration < 9200)
                return 15;
            if (duration < 10800)
                return 30;
            if (duration < 21600)
                return 60;
            return 120;
        });
    }
}
exports.SpriteGenerator = SpriteGenerator;
